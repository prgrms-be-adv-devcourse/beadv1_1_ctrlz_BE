input {
    jdbc {
        jdbc_driver_library => "/opt/logstash/jdbc/mysql-connector-j-9.4.0.jar"
        jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
        jdbc_connection_string => "jdbc:mysql://db-mysql:3306/${MYSQL_DATABASE}"
        jdbc_user => "${MYSQL_USER}"
        jdbc_password => "${MYSQL_PASSWORD}"

        schedule => "* * * * *" # 매 분마다 변경된 상품 정보를 elasticsearch에 보내줌

        last_run_metadata_path => "/usr/share/logstash/.jdbc_last_run_product"

        use_column_value => true

        tracking_column => "updated_at"
        tracking_column_type => "timestamp"

        # SQL 쿼리로 elasticsearch에 보내줄 데이터를 추출
        statement => "
            SELECT
                pp.id, pp.title, pp.name, pp.price, pp.description,
                pp.created_at, pp.updated_at,
                pp.view_count, pp.liked_count,
                pp.status, pp.trade_status, pp.delete_status,
                t.name AS tag_name,
                c.name AS category_name
            FROM product_post pp
            LEFT JOIN product_post_tag ppt ON ppt.product_post_id = pp.id
            LEFT JOIN tag t ON t.id = ppt.tag_id
            LEFT JOIN category c ON c.id = pp.category_id
            WHERE pp.updated_at > :sql_last_value
            ORDER BY pp.updated_at ASC, pp.id ASC
        "
    }
}

filter {
    aggregate {
        task_id => "%{id}"                             # 상품 ID 기준 그룹핑
        code => "
            # 하나의 상품이 가진 여러개의 태그를 하나로 묶기위해 map[] 초기화
            map['tags'] ||= []

            # map에 태그 추가 (null이 아닌 경우만)
            if event.get('tag_name') && !event.get('tag_name').to_s.empty?
                map['tags'] << event.get('tag_name')
            end

            # 상품 정보 저장
            map['id'] = event.get('id')
            map['title'] = event.get('title')
            map['name'] = event.get('name')
            map['price'] = event.get('price')
            map['description'] = event.get('description')
            map['category_name'] = event.get('category_name')
            map['view_count'] = event.get('view_count')
            map['liked_count'] = event.get('liked_count')
            map['status'] = event.get('status')
            map['trade_status'] = event.get('trade_status')
            map['delete_status'] = event.get('delete_status')
            map['created_at'] = event.get('created_at')
            map['updated_at'] = event.get('updated_at')

            # map['tags']로 묶은 뒤 상품 ID가 중복되는 이벤트들은 삭제
            event.cancel()
        "

        # 최종 이벤트 필드 세팅
        timeout_code => "
        # 중복 제거 ([애플, 폰, 애플])
        event.set('tags', map['tags'].uniq)
        "

        # 값이 그루핑 될 때까지 3초 대기
        timeout => 3

        # push_map_as_event_on_timeout = timeout 시 map을 이벤트로 자동변환
        push_map_as_event_on_timeout => true

    }

    # 출력되는 값 후처리
    # _ 로 시작하는 모든 태그 제거 (_aggregateexception 값이 포함되고 있음)
    ruby {
        code => '
            tags = event.get("tags")

            if tags && tags.is_a?(Array)

                clean_tags = tags.reject { |tag|
                    tag_str = tag.to_s
                    tag_str.start_with?("_")
                }

                event.set("tags", clean_tags)
            end
        '
    }
}

# product-posts index로 값들을 보내줌
output {
    elasticsearch {
        hosts => [ "http://elasticsearch:9200" ]
        index => "product-posts"
        document_id => "%{id}"
    }
}